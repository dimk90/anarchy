#!/bin/bash


## Colors


readonly ESC='\033['

# Reset Style and Color
readonly CLEAR="${ESC}0m"
readonly CLR="${ESC}0m"
# Styles
readonly BOLD="${ESC}1m"
readonly DIM="${ESC}2m"
readonly ITALIC="${ESC}3m"
readonly UNDERLINE="${ESC}4m"
readonly BLINK="${ESC}5m"
readonly REVERSE="${ESC}7m"
readonly HIDDEN="${ESC}8m"
# Foreground Colors (bright version)
readonly BLACK="${ESC}90m"
readonly RED="${ESC}91m"
readonly GREEN="${ESC}92m"
readonly YELLOW="${ESC}93m"
readonly BLUE="${ESC}94m"
readonly MAGENTA="${ESC}95m"
readonly CYAN="${ESC}96m"
readonly WHITE="${ESC}97m"
# Standard background
readonly BG_BLACK="${ESC}100m"
readonly BG_RED="${ESC}101m"
readonly BG_GREEN="${ESC}102m"
readonly BG_YELLOW="${ESC}103m"
readonly BG_BLUE="${ESC}104m"
readonly BG_MAGENTA="${ESC}105m"
readonly BG_CYAN="${ESC}106m"
readonly BG_WHITE="${ESC}107m"


## Routines


start_message() {
    #
    # Print standard message prefix.
    #
    printf "%b::%b " "${BOLD}${WHITE}" "${CLR}"
}


start_error() {
    #
    # Print standard error message prefix.
    #
    start_message
    printf "%b[ERROR]%b " "${BOLD}${RED}" "${CLR}"
}

start_result()
{
    printf "   %b->%b " "${BOLD}${GREEN}" "${CLR}"
}


info() {
    #
    # Print an info message with standard prefix.
    #
    # Example:
    #   message "Installing configs..."
    #
    start_message
    printf "${DIM}%b${CLR}" "$1"
}


error() {
    #
    # Print an error message with standard prefix.
    #
    # Example:
    #   error "Failed to install configs"
    #
    start_error
    printf "${DIM}%b${CLR}" "$1"
}


warning() {
    #
    # Print a warning message with standard prefix.
    #
    # Example:
    #   warning "Config file already exists, skipping"
    #
    start_warning
    printf "${DIM}%b${CLR}" "$1"
}


log_result() {
    #
    # Print a result message with result prefix.
    #
    # Example:
    #   log_result "Config installed"
    #
    start_result
    printf "${DIM}%b${CLR}" "$1"
}


as_root() {
    #
    # Execute command as root (add sudo if necessary).
    # Returns the exit code of the command.
    #
    # Example:
    #   as_root pacman -Sy gum
    #
    if [ "$EUID" -eq 0 ]; then
        "$@"
    else
        sudo "$@"
    fi
}


as_root_verbose() {
    #
    # Execute command as root (add sudo if necessary).
    # Prints the command being executed.
    # Returns the exit code of the command.
    #
    # Example:
    #   as_root_verbose pacman -Sy gum
    #
    info "$*\n"

    as_root "$@"
    local exit_code=$?

    echo
    return "$exit_code"
}


check_sudo() {
    #
    # Check if sudo is needed (i.e., if not running as root).
    # Returns "sudo" if needed, empty string otherwise.
    #
    # Example:
    #   SUDO_PREFIX=$(check_sudo)
    #   $SUDO_PREFIX pacman -Sy gum
    #
    if [ "$EUID" -eq 0 ]; then
        # root already -> no need sudo
        echo ""
    else
        echo "sudo"
    fi
}


have_privilege() {
    #
    # Check whether the script has root privileges or a cached sudo credential.
    # Returns 0 if running as root or if `sudo` can be used without requiring a password,
    # returns 1 otherwise (sudo is required).
    #
    # Example:
    #   if have_privilege; then
    #       as_root pacman -Sy gum
    #   else
    #       info "Need password to perform privileged actions"
    #   fi
    #
    if [ "$EUID" -eq 0 ]; then
        # root privilege
        return 0
    fi

    # need sudo
    if sudo -n true &> /dev/null; then
        # the privilege is still valid since last request
        return 0
    fi

    return 1 # need password
}


assert() {
    #
    # Assert that the given exit code is zero (the first argument);
    # if not, print the given message and exit with code 1.
    #
    # Example:
    #   as_root pacman -Sy gum
    #   assert $? "failed to install gum"
    #
    local exit_code="$1"
    local message="$2"

    if [ "$exit_code" -ne 0 ]; then
        error "${message}\n"
        exit 1
    fi
}


ask_yn() {
    #
    # Ask a yes/no question, return 0 for yes, 1 for no
    #
    # Example:
    #   printf "Install gum? "
    #   if ask_yn; then as_root pacman -Sy gum; fi
    #
    printf "(y/n): "

    # read input from /dev/tty to work correctly when stdin is redirected
    # e.g., curl -fsSL ...install.sh | bash
    read -r reply </dev/tty

    if [[ $reply =~ ^[Yy]$ ]]; then
        return 0
    else
        return 1
    fi
}


is_package_installed() {
    #
    # Check if a package installed.
    #
    # Parameters:
    #   $1 - package name
    #
    local package="$1"

    pacman -Qi "${package}" &> /dev/null && return 0
    return 1
}


request_package() {
    #
    # Request user to install a package if it's not already installed.
    #
    # Example:
    #   request_package "git"
    #   assert $? "failed to install git"
    #
    local package="$1"

    is_package_installed "$package" && return 0
    as_root_verbose pacman -Sy "$package" </dev/tty
}


request_gum() {
    #
    # Request user to install gum if it's not already installed.
    #
    # Example:
    #   gum_request
    #   assert $? "no gum - no fun :("
    #
    command -v gum &> /dev/null && return 0

    info "The UI ${CLR}${BOLD}${MAGENTA}gum${CLR}${DIM} not found. Let's get some? "

    if ask_yn; then
        as_root_verbose pacman -Sy gum </dev/tty
        return $?
    else
        return 1
    fi
}


is_command_available() {
    #
    # Check if a command is available in the system.
    #
    # Example:
    #   if is_command_available "git"; then ...
    #
    local command_name="$1"

    command -v "$command_name" &> /dev/null
    return $?
}


choices_to_indices() {
    #
    # Convert a newline-separated string of choices into their corresponding
    # indices in the provided source array.
    #
    # Example:
    #   indices=($(choices_to_indices "$file_choices" "${CONFIG_FILES[@]}"))
    #
    local choices="$1"
    shift
    local source_array=("$@")

    # Convert choices to array using mapfile
    local selected_items=()
    mapfile -t selected_items <<< "$choices"

    # Find indices
    local indices=()
    for item in "${selected_items[@]}"; do
        [[ -z "$item" ]] && continue  # Skip empty lines
        for i in "${!source_array[@]}"; do
            if [[ "${source_array[$i]}" == "$item" ]]; then
                indices+=("$i")
                break
            fi
        done
    done

    # Return indices as space-separated string
    echo "${indices[@]}"
}


array_contains() {
    #
    # Check if an array contains item(s) matching a given pattern.
    # The matching is case-sensitive and supports shell globbing.
    #
    # Example:
    #   if array_contains "^Keymap*" "${array[@]}"; then ...
    #
    local pattern="$1"
    shift
    local items=("$@")

    for item in "${items[@]}"; do
        if [[ $item =~ $pattern ]]; then
            return 0 # pattern found
        fi
    done

    return 1
}


backup_file() {
    #
    # Create a backup of the given file by appending .bakN
    # where N is the next available number.
    #
    # Parameters:
    #   $1 - filename to backup
    #   $2 - (optional) prefix command (e.g., "sudo")
    #
    # Example:
    #    backup_name=$(backup_file "$file")
    #    assert $? "backup failed for $file"
    #
    #    backup_name=$(backup_file "$file" "sudo")
    #    assert $? "backup failed for $file (with sudo)"
    #
    local filename="$1"
    local prefix="$2"

    # Ð¢o target file -> nothing to back up
    if [[ ! -f $filename ]]; then
        echo ""  # return empty string
        return 0 # no error
    fi

    # Find the next available backup number
    local idx=1
    local backup_name="${filename}.bak${idx}"

    while [[ -f $backup_name ]]; do
        ((idx++))
        backup_name="${filename}.bak${idx}"
    done

    # Create the backup
    if $prefix cp "${filename}" "${backup_name}" 2>/dev/null; then
        echo "${backup_name}" # return backup filename
        return 0
    else
        echo ""  # return empty string - no backup created
        return 1
    fi
}


remove_line() {
    #
    # Remove lines matching a given pattern from a file.
    # Parameters:
    #   $1 - file to modify
    #   $2 - pattern to match (sed regex)
    #   $3 - (optional) prefix command (e.g., "sudo")
    #
    # Example:
    #   remove_line "/etc/vconsole.conf" "^FONT="
    #   assert $? "failed to remove line from /etc/vconsole.conf"
    #
    #   remove_line "/etc/vconsole.conf" "^FONT=" "sudo"
    #   assert $? "failed to remove line from /etc/vconsole.conf (with sudo)"
    #
    local file="$1"
    local pattern="$2"
    local prefix="$3"

    # Check if both parameters are provided
    if [[ -z $file || -z $pattern ]]; then
        assert 1 "both <file> and <pattern> parameters are required"
    fi

    # Check if file exists
    if [[ ! -f $file ]]; then
        return 0 # not file -> no line -> done
    fi

    # Remove lines matching the pattern using sed
    # -i flag edits the file in-place
    # The pattern is escaped to handle special characters safely
    if ! $prefix sed -i "\|${pattern}|d" "$file"; then
        return 1
    fi

    return 0
}


replace_line() {
    #
    # Replace lines matching a given pattern in a file with a new line.
    # Parameters:
    #   $1 - file to modify
    #   $2 - pattern to match (sed regex)
    #   $3 - new line to insert
    #   $4 - (optional) prefix command (e.g., "sudo")
    #
    # Example:
    #   replace_line "/etc/vconsole.conf" "^FONT=" "FONT=ter-124b"
    #   assert $? "failed to replace line in /etc/vconsole.conf"
    #
    #   replace_line "/etc/vconsole.conf" "^FONT=" "FONT=ter-124b" "sudo"
    #   assert $? "failed to replace line in /etc/vconsole.conf (with sudo)"
    #
    local file="$1"
    local pattern="$2"
    local new_line="$3"
    local prefix="$4"

    # Check if all parameters are provided
    if [[ -z $file || -z $pattern || -z $new_line ]]; then
        assert 1 "parameters <file>, <pattern>, and <new_line> are required"
    fi

    # Check if file exists
    if [[ ! -f $file ]]; then
        return 1 # file not found
    fi

    # Replace lines matching the pattern using sed
    if ! $prefix sed -i "\|${pattern}|c\\${new_line}" "$file"; then
        return 1
    fi

    return 0
}
