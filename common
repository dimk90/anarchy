#!/bin/bash

export COMMON_VERSION='2.0'


## Colors


# Selected Gum Colors (ANSI)

export GUM_CYAN=44
export GUM_BLUE=39
export GUM_YELLOW=226
export GUM_RED=160
export GUM_GREEN=77
export GUM_MAGENTA=212
export GUM_WHITE=231

# ANSI Colors with escape sequence

export STYLE_ESC='\033['
# Reset Style and Color
export STYLE_CLEAR="${STYLE_ESC}0m"
export STYLE_CLR="${STYLE_CLEAR}"
# Styles
export STYLE_BOLD="${STYLE_ESC}1m"
export STYLE_DIM="${STYLE_ESC}2m"
export STYLE_ITALIC="${STYLE_ESC}3m"
export STYLE_UNDERLINE="${STYLE_ESC}4m"
export STYLE_BLINK="${STYLE_ESC}5m"
export STYLE_REVERSE="${STYLE_ESC}7m"
export STYLE_HIDDEN="${STYLE_ESC}8m"
# Foreground Colors (bright version)
export FG_BLACK="${STYLE_ESC}90m"
export FG_RED="${STYLE_ESC}91m"
export FG_GREEN="${STYLE_ESC}92m"
export FG_YELLOW="${STYLE_ESC}93m"
export FG_BLUE="${STYLE_ESC}94m"
export FG_MAGENTA="${STYLE_ESC}95m"
export FG_CYAN="${STYLE_ESC}96m"
export FG_WHITE="${STYLE_ESC}97m"
# Standard background
export BG_BLACK="${STYLE_ESC}100m"
export BG_RED="${STYLE_ESC}101m"
export BG_GREEN="${STYLE_ESC}102m"
export BG_YELLOW="${STYLE_ESC}103m"
export BG_BLUE="${STYLE_ESC}104m"
export BG_MAGENTA="${STYLE_ESC}105m"
export BG_CYAN="${STYLE_ESC}106m"
export BG_WHITE="${STYLE_ESC}107m"


## Style


# accent color
export FG_ACCENT=$FG_GREEN
export GUM_ACCENT=$GUM_GREEN

# gum subcommands style
export GUM_SPIN_SPINNER_FOREGROUND=$GUM_WHITE
export GUM_INPUT_CURSOR_FOREGROUND=$GUM_ACCENT
export GUM_CHOOSE_SELECTED_FOREGROUND=$GUM_ACCENT
export GUM_CHOOSE_CURSOR_FOREGROUND=$GUM_CHOOSE_SELECTED_FOREGROUND
export GUM_CHOOSE_HEADER_FOREGROUND=$GUM_WHITE

# spinner
if [ "$TERM" = "linux" ]; then
    # vconsole font is limited
    export GUM_SPIN_SPINNER="line"
else
    export GUM_SPIN_SPINNER="minidot"
fi

# The minimum delay for displaying a some status before changing it
export UI_INTERACTION_DELAY=0.6 # sec


## Logger


# Path to current log file. If unset or set to "/dev/null", start_logger()
# will create a temporary log file and assign it to LOG_FILE.
export LOG_FILE=/dev/null


start_logger() {
    #
    # Initialize LOG_FILE for logging.
    # If LOG_FILE points to /dev/null, creates a temporary file
    # (using mktemp) and assigns it to LOG_FILE.
    #
    # Example:
    #   start_logger
    #   echo " -> start log: $(get_logger)"
    #
    if [ "$LOG_FILE" = "/dev/null" ]; then
        LOG_FILE="$(mktemp).log"
        assert $? "can't create log file in /tmp"
    fi
}


get_logger() {
    #
    # Prints the path of the current LOG_FILE to stdout.
    #
    echo "$LOG_FILE"
}


reset_logger() {
    #
    # Sets LOG_FILE back to /dev/null so logging is effectively disabled
    # until start_logger is called again.
    #
    LOG_FILE=/dev/null
}


## Common


is_command_available() {
    #
    # Check if a command is available in the system.
    #
    # Example:
    #   if is_command_available "git"; then ...
    #
    local command_name="$1"

    command -v "$command_name" &> /dev/null
}


assert() {
    #
    # Assert that the given exit code is zero (the first argument);
    # if not, print the given message and exit with code 1.
    #
    # Example:
    #   as_root pacman -Sy gum
    #   assert $? "failed to install gum"
    #
    local exit_code="$1"
    local message="${2-¯\_(ツ)_/¯}"

    if [ "$exit_code" -ne 0 ]; then
        printf_error "%b\n" "${message}"
        exit 1
    fi
}


regex_sanitize() {
    #
    # Remove regex metacharacters and apply escaping to string.
    #
    # Example:
    #    regex_sanitize '^Color$' -> Output: 'Color'
    #    regex_sanitize '^Color\s*=\s*red$' -> Output: 'Color=red'
    #
    # shellcheck disable=SC2001
    echo "$1" | sed \
        's/\\[bsdwBSDW][*+?]\?//g; # Remove character class patterns with quantifiers:
                                   # \s* \s+ \s? ...

        s/\\\$/$/g;                # Unescape escaped dollar signs: \$ becomes $
                                   # This must come before removing all backslashes

        s/\\//g;                   # Remove remaining backslashes (escape character)

        s/\^//g;                   # Remove ^ (start of line anchor)
        s/\$//g;                   # Remove $ (end of line anchor)

        s/[*+?.()\[\]{}|]//g       # Remove other regex special characters:
                                   # *, +, ?, ., (), [], {}, |
    '
}


## Print


# The output structure:
#
# :: <section_title>
#    -> <action_title> [- <status>]
#    -> <action_title> [- <status>]
#    -> <action_title> [- <status>]
# :: <section_title>
#    -> <action_title> [- <status>]
# [WARNING] <message>
# :: <section_title>
#    -> <action_title> [- <status>]
#    -> <action_title> [- <status>]
# [ERROR] <message>


bullet_section() {
    #
    # Output section bullet with applied style.
    #
    if is_command_available "gum"; then
        gum style --bold --foreground "$GUM_WHITE" '::'
    else
        printf "%b::%b"       \
            "${STYLE_BOLD}${FG_WHITE}" \
            "${STYLE_CLR}"
    fi
}


bullet_action() {
    #
    # Output action bullet with applied style.
    #
    if is_command_available "gum"; then
        gum style --bold --foreground "$GUM_ACCENT" '   ->'
    else
        printf "   %b->%b"     \
            "${STYLE_BOLD}${FG_ACCENT}" \
            "${STYLE_CLR}"
    fi
}


bullet_warning() {
    #
    # Output warning bullet with applied style.
    #
    if is_command_available "gum"; then
        printf "%b%b%b"                                              \
            "$(gum style --faint '[')"                               \
            "$(gum style --bold --foreground $GUM_YELLOW 'WARNING')" \
            "$(gum style --faint ']')"
    else
        printf "%b%b%b"                     \
            "${STYLE_DIM}[${STYLE_CLR}"                 \
            "${STYLE_BOLD}${FG_YELLOW}WARNING${STYLE_CLR}" \
            "${STYLE_DIM}]${STYLE_CLR}"
    fi
}


bullet_error() {
    #
    # Output error bullet with applied style.
    #
    if is_command_available "gum"; then
        printf "%b%b%b"                                         \
            "$(gum style --faint '[')"                          \
            "$(gum style --bold --foreground $GUM_RED 'ERROR')" \
            "$(gum style --faint ']')"
    else
        printf "%b%b%b"                \
            "${STYLE_DIM}[${STYLE_CLR}"            \
            "${STYLE_BOLD}${FG_RED}ERROR${STYLE_CLR}" \
            "${STYLE_DIM}]${STYLE_CLR}"
    fi
}


prefix_printf() {
    local prefix="$1"
    local title="$2"

    if is_command_available "gum"; then
        title="$(gum style --faint "$title")"
    else
        title="${STYLE_DIM}${title}${STYLE_CLR}"
    fi

    printf "%b ${title}" "$prefix" "${@:3}"
}


printf_section() {
    #
    # Print a section title with section prefix and style.
    #
    # Example:
    #   printf_section "Config file already exists, skipping"
    #   printf_section "Config file %s skipping" "${CONFIG_FILE}"
    #
    local title="$1"
    prefix_printf "$(bullet_section)" "${title}" "${@:2}"
}


printf_action() {
    #
    # Print a action title with action prefix and style.
    #
    # Example:
    #   printf_action "Install package gum - %b" "${INSTALL_STATUS}"
    #
    local title="$1"
    prefix_printf "$(bullet_action)" "${title}" "${@:2}"
}


printf_warning() {
    #
    # Print a warning message with the warning prefix.
    #
    # Example:
    #   printf_warning "Config file already exists"
    #
    local title="$1"
    prefix_printf "$(bullet_warning)" "${title}" "${@:2}"
}


printf_error() {
    #
    # Print a error message with the error prefix.
    #
    # Example:
    #   printf_error "Can't install package"
    #
    local title="$1"
    prefix_printf "$(bullet_error)" "${title}" "${@:2}"
}


## Input


ask_yn() {
    #
    # Ask a yes/no question, return 0 for yes, 1 for no
    #
    # Example:
    #   printf "Install gum? "
    #   if ask_yn; then as_root pacman -Sy gum; fi
    #
    printf "(y/n): "

    # read input from /dev/tty to work correctly when stdin is redirected
    # e.g., curl -fsSL ...install.sh | bash
    read -r reply </dev/tty

    if [[ $reply =~ ^[Yy]$ ]]; then
        return 0
    else
        return 1
    fi
}


## Root & Privilege


as_root() {
    #
    # Execute command as root (add sudo if necessary).
    # Returns the exit code of the command.
    #
    # Example:
    #   as_root pacman -Sy gum
    #
    if [ "$EUID" -eq 0 ]; then
        "$@"
    else
        sudo "$@"
    fi
}


check_sudo() {
    #
    # Check if sudo is needed (i.e., if not running as root).
    # Returns "sudo" if needed, empty string otherwise.
    #
    # Example:
    #   SUDO_PREFIX=$(check_sudo)
    #   $SUDO_PREFIX pacman -Sy gum
    #
    if [ "$EUID" -eq 0 ]; then
        # root already -> no need sudo
        echo ""
    else
        echo "sudo"
    fi
}


have_privilege() {
    #
    # Check whether the script has root privileges or a cached sudo credential.
    # Returns 0 if running as root or if `sudo` can be used without requiring a password,
    # returns 1 otherwise (sudo is required).
    #
    # Example:
    #   if have_privilege; then
    #       as_root pacman -Sy gum
    #   else
    #       info "Need password to perform privileged actions"
    #   fi
    #
    if [ "$EUID" -eq 0 ]; then
        # root privilege
        return 0
    fi

    # need sudo
    # shellcheck disable=SC2024
    if sudo -n true &>> "$LOG_FILE"; then
        # the privilege is still valid since last request
        return 0
    fi

    return 1 # need password
}


## Package Management


is_package_installed() {
    #
    # Check if a package installed.
    #
    # Parameters:
    #   $1 - package name
    #
    local package="$1"

    pacman -Qi "${package}" &>> "$LOG_FILE" && return 0
    return 1
}


request_gum() {
    #
    # Request user to install gum if it's not already installed.
    #
    # Example:
    #   gum_request
    #   assert $? "no gum - no fun :("
    #
    is_command_available "gum" && return 0

    printf_section "The UI%b gum%b not found. Let's get some? " \
        "${STYLE_CLR}${STYLE_BOLD}${FG_MAGENTA}" \
        "${STYLE_CLR}${STYLE_DIM}"

    if ask_yn; then
        printf_action "pacman -Sy gum\n"
        as_root pacman -Sy gum </dev/tty
        echo
    else
        return 1
    fi
}


## Array


choices_to_indices() {
    #
    # Convert a newline-separated string of choices into the indices of matching
    # items in the provided source array. Indices are printed separated by spaces.
    #
    # Example:
    #   indices=($(choices_to_indices "$file_choices" "${CONFIG_FILES[@]}"))
    #
    local choices="$1"
    shift
    local source_array=("$@")

    # Convert choices to array using mapfile
    local selected_items=()
    mapfile -t selected_items <<< "$choices"

    # Find indices
    local indices=()
    for item in "${selected_items[@]}"; do
        [[ -z "$item" ]] && continue  # skip empty lines
        for i in "${!source_array[@]}"; do
            if [[ "${source_array[$i]}" == "$item" ]]; then
                indices+=("$i")
                break
            fi
        done
    done

    # Print indices separated by spaces (suitable for capture with array=(...))
    echo "${indices[*]}"
}


array_contains() {
    #
    # Check whether an array contains one or more items matching a given pattern.
    # Matching is case-sensitive and uses Bash extended regular expressions (the [[ =~ ]] operator).
    #
    # Example:
    #   if array_contains '^Keymap.*' "${array[@]}"; then ...
    #
    local pattern="$1"
    shift
    local items=("$@")

    for item in "${items[@]}"; do
        if [[ $item =~ $pattern ]]; then
            return 0 # pattern found
        fi
    done

    return 1
}


## Files & Env


backup_file() {
    #
    # Create a backup of the given file by appending .bakN
    # where N is the next available number.
    #
    # Parameters:
    #   $1 - filename to backup
    #   $2 - (optional) prefix command (e.g., "sudo")
    #
    # Example:
    #    backup_name=$(backup_file "$file")
    #    assert $? "backup failed for $file"
    #
    #    backup_name=$(backup_file "$file" "sudo")
    #    assert $? "backup failed for $file (with sudo)"
    #
    local filename="$1"
    local prefix="${2-}"

    # If the target file does not exist, there's nothing to back up.
    if [[ ! -f $filename ]]; then
        echo ""  # return empty string
        return 0 # no error
    fi

    # Find the next available backup number
    local idx=1
    local backup_name="${filename}.bak${idx}"

    while [[ -f $backup_name ]]; do
        ((idx++))
        backup_name="${filename}.bak${idx}"
    done

    # Create the backup
    if $prefix cp "${filename}" "${backup_name}" &>> "$LOG_FILE"; then
        echo "${backup_name}" # return backup filename
        return 0
    else
        echo ""  # return empty string - no backup created
        return 1
    fi
}


remove_line() {
    #
    # Remove lines matching a given pattern from a file.
    # The pattern matching is case sensitive by default.
    # Return 0 if the file does not exist or if no matching lines are found.
    #
    # Parameters:
    #   $1 - file to modify
    #   $2 - pattern to match (sed regex)
    #   $3 - (optional) prefix command (e.g., "sudo")
    #   $4 - (optional) set to "i" or "I" for case-insensitive matching
    #
    # Example:
    #   remove_line "/etc/vconsole.conf" "^FONT="
    #   assert $? "failed to remove line from /etc/vconsole.conf"
    #
    #   remove_line "/etc/vconsole.conf" "^FONT=" "sudo"
    #   assert $? "failed to remove line from /etc/vconsole.conf (with sudo)"
    #
    #   remove_line "/etc/vconsole.conf" "^font=" "" "i"
    #   assert $? "failed to remove line (case-insensitive)"
    #
    local file="$1"
    local pattern="$2"
    local prefix="${3-}"
    local case_mode="${4-}"

    # Check if both parameters are provided
    if [[ -z $file || -z $pattern ]]; then
        assert 1 "parameters <file> and <pattern> are required"
    fi

    # Check if file exists
    if [[ ! -f $file ]]; then
        return 0 # not a file -> no lines -> done
    fi

    # Remove lines matching the pattern using sed (in-place).
    # The pattern is surrounded by '|' delimiters to avoid escaping slashes.
    if ! $prefix sed -i "\|${pattern}|${case_mode^^}d" "$file" &>> "$LOG_FILE"; then
        return 1
    fi

    return 0
}


replace_line() {
    #
    # Replace lines matching a given pattern in a file with a new line.
    #
    # Parameters:
    #   $1 - file to modify
    #   $2 - pattern to match (sed regex)
    #   $3 - new line to insert
    #   $4 - (optional) prefix command (e.g., "sudo")
    #
    # Example:
    #   replace_line "/etc/vconsole.conf" "^FONT=" "FONT=ter-124b"
    #   assert $? "failed to replace line in /etc/vconsole.conf"
    #
    #   replace_line "/etc/vconsole.conf" "^FONT=" "FONT=ter-124b" "sudo"
    #   assert $? "failed to replace line in /etc/vconsole.conf (with sudo)"
    #
    local file="$1"
    local pattern="$2"
    local new_line="$3"
    local prefix="${4-}"

    # Check if all parameters are provided
    if [[ -z $file || -z $pattern || -z $new_line ]]; then
        assert 1 "parameters <file>, <pattern>, and <new_line> are required"
    fi

    # Check if file exists
    if [[ ! -f $file ]]; then
        return 1 # file not found
    fi

    # Replace lines matching the pattern using sed
    if ! $prefix sed -i "\|${pattern}|c\\${new_line}" "$file" &>> "$LOG_FILE"; then
        return 1
    fi

    return 0
}


env_set_permanent() {
    #
    # Set an environment variable permanently across shell sessions.
    # Attempts to set the variable in all available shells (fish, bash, ...).
    # Returns 0 if successful in at least one shell, non-zero otherwise.
    #
    # Parameters:
    #   $1 - variable name (e.g., "EDITOR")
    #   $2 - variable value (e.g., "nano")
    #
    # Outputs:
    #   Prints comma-separated list of shells where variable was set successfully
    #   (e.g., "fish,bash" or "bash" or empty string if all failed)
    #
    # Example:
    #   shells=$(env_set_permanent "EDITOR" "nano")
    #   assert $? "failed to set EDITOR permanently"
    #   echo "Set in: $shells"
    #
    local var_name="$1"
    local var_value="$2"

    local result_code=0
    local result_msg=""

    # fish
    if is_command_available "fish"; then
        ((result_code += 1))
        # set fish universal variable:
        # shared across all fish sessions, persists after reboot
        if fish -c "set -Ux $var_name $var_value" &>> "$LOG_FILE"; then
            ((result_code -= 1))
            # Append fish to the current result msg
            [ -z "$result_msg" ] && result_msg="fish" || result_msg="${result_msg},fish"
        fi
    fi

    # bash
    if is_command_available "bash"; then
        ((result_code += 1))
        # set permanent variable:
        # remove current variable (if present) and add new
        if remove_line ~/.bashrc "^export ${var_name}=" "" "i" &&
           echo "export ${var_name}=\"${var_value}\"" >> ~/.bashrc; then
            ((result_code -= 1))
            # Append bash to the current result msg
            [ -z "$result_msg" ] && result_msg="bash" || result_msg="${result_msg},bash"
        fi
    fi

    echo "$result_msg"
    return $result_code
}


## TUI - gum-based


action_require_package() {
    #
    # Install a package using pacman with interactive UI and privilege handling.
    # Exit with 1 on failure.
    #
    # Parameters:
    #   $1 - package - The name of the package to install.
    #   $2 - title_prefix - A prefix string used when rendering UI titles (optional).
    #
    # Example:
    #   action_require_package "nano"
    #
    local package="$1"
    local title_prefix="${2-$(bullet_action) }"

    is_command_available "gum"
    assert $? "gum is required"

    action_title=$(printf "%b%b %b" "$title_prefix"  \
        "$(gum style --faint 'Package')"    \
        "$(gum style --bold --foreground "$GUM_ACCENT" "$package")" \
    )

    # check if package already installed
    gum spin --align="right" \
             --title "${action_title}$(gum style --faint ' - checking')" \
             -- sleep $UI_INTERACTION_DELAY

    if is_package_installed "$package"; then
        printf "%b\n" "${action_title}$(gum style --faint ' - exists')"
        return 0
    fi

    # request privilege
    gum spin --align="right" \
             --title "${action_title}$(gum style --faint ' - privilege')" \
             -- sleep $UI_INTERACTION_DELAY

    if ! have_privilege; then
        password=$(gum input --password --char-limit=30 \
                             --no-show-help             \
                             --placeholder "enter your password for sudo" \
                             --prompt "${action_title} $(gum style --foreground "$GUM_WHITE" '>') ")
        assert $? "password request failed"

        # shellcheck disable=SC2024
        echo "$password" | sudo -Si true &>> "$LOG_FILE"
        assert $? "privilege request failed"
    fi

    # pacman & spinner
    gum spin --align="right"  \
             --title "${action_title}$(gum style --faint ' - installing')" \
             -- bash -c "$(check_sudo) pacman --noconfirm -Sy ${package} &>> ${LOG_FILE}"
    assert $? "can't install package"

    printf "%b\n" "${action_title}$(gum style --faint ' - installed')"
}


action_install_file() {
    #
    # Download and install a file to the given destination path.
    # If a file already exists at the destination, a backup will be created.
    # Exits with status 1 on failure.
    #
    # Parameters:
    #   $1 - file path - destination path for the file
    #   $2 - file url - URL to download the file from
    #   $3 - prefix (optional) - prefix command (e.g., "sudo")
    #
    # Example:
    #   action_install_file "/etc/vconsole.conf" "https://example.com/vconsole.conf" "sudo"
    #
    local file_path="$1"
    local file_url="$2"
    local prefix="${3-}"

    local basename="${file_path##*/}"

    # Get unique temp file name
    local tmpfile
    tmpfile="$(mktemp)"
    assert $? "can't create temporary file"

    # Register cleanup trap
    # shellcheck disable=SC2064
    trap "rm -f $tmpfile" EXIT

    # Download file
    action_run "Download file: $basename"        \
        "curl -fsSL ${file_url} -o ${tmpfile}" \
        'done'
    assert $? "can't download keymap file"

    # Backup existing config file (if exists)
    if [ -f "$file_path" ]; then
        # Check if sudo required
        [ "${prefix,,}" = 'sudo' ] && action_request_permission
        backup_file=$(backup_file "$file_path" "$prefix")
        assert $? "can't backup: $basename"
        action_run "Backup $basename -> $backup_file" "" 'done'
    fi

    # Move downloaded file to the target location
    [ "${prefix,,}" = 'sudo' ] && action_request_permission
    action_run "$(printf "%b %b %b"      \
        "$(gum style --faint 'Install')" \
        "$(gum style --foreground $GUM_YELLOW "$basename")" \
        "$(gum style --faint "to $file_path")${STYLE_DIM}" \
    )" "$prefix mv $tmpfile $file_path" 'done'
    assert $? "can't move $tmpfile -> $file_path"
}


action_run() {
    #
    # Run a command with spinner. Print success status on completion if provided.
    # Return the command exit code.
    #
    # Parameters:
    #   $1 - title - the action title to show.
    #   $2 - command - a command to run. The 'sleep' will be used if not provided.
    #   $3 - status (optional) - text to show when the command successfully finished.
    #
    local title="$1"
    local command="${2-}"
    local status="${3-}"

    is_command_available "gum"
    assert $? "gum is required"

    # If command is missing set it to the minimal UI sleep
    if [ -z "$command" ]; then
        command="sleep $UI_INTERACTION_DELAY"
    fi

    # Run command and show spinner
    gum spin --align="right" --title "$(printf_action "${title} -")" \
        -- bash -c "$command"

    # Return exit code and skip status if non-zero
    exit_code=$?
    if [ $exit_code -ne 0 ]; then
        printf_action "%b - %b\n" "$title" \
                      "$(gum style --foreground $GUM_RED "failed")"
        return $exit_code
    fi

    # Show status if provided and command finished without an error
    if [ -z "$status" ]; then
        printf_action "%b\n" "$title"
    else
        printf_action "%b - %b\n" "$title" \
                      "$(gum style --foreground $GUM_GREEN "$status")"
    fi
}


action_request_permission() {
    #
    # Request root privilege via sudo and gum UI.
    # Exit with 1 on failure.
    #
    # Parameters:
    #   $1 - reason text (optional).
    #
    local reason_text="${1-}"

    have_privilege && return 0

    # request user password for sudo
    [ -n "$reason_text" ] && reason_text=" $reason_text"
    request_title=$(printf_action "Request permission%b" "$reason_text")

    password=$(gum input --password --char-limit=30 \
                         --no-show-help             \
                         --placeholder "enter your password for sudo" \
                         --prompt "${request_title} $(gum style --foreground "$GUM_WHITE" '>') ")
    assert $? "password request failed"

    # shellcheck disable=SC2024
    echo "$password" | sudo -Si true &>> "$LOG_FILE"
    assert $? "permission request failed"

    printf_action "Request permission%b - granted\n" "$reason_text"
}


## Export Functions


# Logger
export -f start_logger
export -f get_logger
export -f reset_logger

# Common
export -f is_command_available
export -f assert
export -f regex_sanitize

# Print
export -f bullet_section
export -f bullet_action
export -f bullet_warning
export -f bullet_error
export -f prefix_printf
export -f printf_section
export -f printf_action
export -f printf_warning
export -f printf_error

# Input
export -f ask_yn

# Root & Privilege
export -f as_root
export -f check_sudo
export -f have_privilege

# Package Management
export -f is_package_installed
export -f request_gum

# Array
export -f choices_to_indices
export -f array_contains

# Files & Env
export -f backup_file
export -f remove_line
export -f replace_line
export -f env_set_permanent
export -f check_sudo
