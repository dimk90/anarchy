#!/bin/bash

# shellcheck disable=SC2034
readonly VERSION='1.0'


## Colors


# shellcheck disable=SC2034
{

# Selected Gum Colors (ANSI)

readonly GUM_CYAN=44
readonly GUM_BLUE=39
readonly GUM_YELLOW=226
readonly GUM_RED=160
readonly GUM_GREEN=77
readonly GUM_MAGENTA=212
readonly GUM_WHITE=231

# ANSI Colors with escape sequence

readonly ESC='\033['
# Reset Style and Color
readonly CLEAR="${ESC}0m"
readonly CLR="${CLEAR}"
# Styles
readonly BOLD="${ESC}1m"
readonly DIM="${ESC}2m"
readonly ITALIC="${ESC}3m"
readonly UNDERLINE="${ESC}4m"
readonly BLINK="${ESC}5m"
readonly REVERSE="${ESC}7m"
readonly HIDDEN="${ESC}8m"
# Foreground Colors (bright version)
readonly BLACK="${ESC}90m"
readonly RED="${ESC}91m"
readonly GREEN="${ESC}92m"
readonly YELLOW="${ESC}93m"
readonly BLUE="${ESC}94m"
readonly MAGENTA="${ESC}95m"
readonly CYAN="${ESC}96m"
readonly WHITE="${ESC}97m"
# Standard background
readonly BG_BLACK="${ESC}100m"
readonly BG_RED="${ESC}101m"
readonly BG_GREEN="${ESC}102m"
readonly BG_YELLOW="${ESC}103m"
readonly BG_BLUE="${ESC}104m"
readonly BG_MAGENTA="${ESC}105m"
readonly BG_CYAN="${ESC}106m"
readonly BG_WHITE="${ESC}107m"
}


## Style


# accent color
export ACCENT=$GREEN
export GUM_ACCENT=$GUM_GREEN

# gum subcommands style
export GUM_SPIN_SPINNER_FOREGROUND=$GUM_WHITE
export GUM_INPUT_CURSOR_FOREGROUND=$GUM_ACCENT

# spinner
if [ "$TERM" = "linux" ]; then
    # vconsole font is limited
    export GUM_SPIN_SPINNER="line"
else
    export GUM_SPIN_SPINNER="minidot"
fi

# The minimum delay for displaying a some status before changing it
UI_INTERACTION_DELAY=1 # sec


## Logger


# Path to current log file. If unset or set to "/dev/null", start_logger()
# will create a temporary log file and assign it to LOG_FILE.
LOG_FILE=/dev/null


start_logger() {
    #
    # Initialize LOG_FILE for logging.
    # If LOG_FILE points to /dev/null, creates a temporary file
    # (using mktemp) and assigns it to LOG_FILE.
    #
    # Example:
    #   start_logger
    #   echo " -> start log: $(get_logger)"
    #
    if [ "$LOG_FILE" = "/dev/null" ]; then
        LOG_FILE="$(mktemp).log"
        assert $? "can't create log file in /tmp"
    fi
}


get_logger() {
    #
    # Prints the path of the current LOG_FILE to stdout.
    #
    echo "$LOG_FILE"
}


reset_logger() {
    #
    # Sets LOG_FILE back to /dev/null so logging is effectively disabled
    # until start_logger is called again.
    #
    LOG_FILE=/dev/null
}


## Common


is_command_available() {
    #
    # Check if a command is available in the system.
    #
    # Example:
    #   if is_command_available "git"; then ...
    #
    local command_name="$1"

    command -v "$command_name" &> /dev/null
}


assert() {
    #
    # Assert that the given exit code is zero (the first argument);
    # if not, print the given message and exit with code 1.
    #
    # Example:
    #   as_root pacman -Sy gum
    #   assert $? "failed to install gum"
    #
    local exit_code="$1"
    local message="${2-¯\_(ツ)_/¯}"

    if [ "$exit_code" -ne 0 ]; then
        printf_error "%b\n" "${message}"
        exit 1
    fi
}


## Print


# The output structure:
#
# :: <section_title>
#    -> <action_title> [- <status>]
#    -> <action_title> [- <status>]
#    -> <action_title> [- <status>]
# :: <section_title>
#    -> <action_title> [- <status>]
# [WARNING] <message>
# :: <section_title>
#    -> <action_title> [- <status>]
#    -> <action_title> [- <status>]
# [ERROR] <message>


bullet_section() {
    #
    # Output section bullet with applied style.
    #
    if is_command_available "gum"; then
        gum style --bold --foreground "$GUM_WHITE" '::'
    else
        printf "%b::%b"       \
            "${BOLD}${WHITE}" \
            "${CLR}"
    fi
}


bullet_action() {
    #
    # Output action bullet with applied style.
    #
    if is_command_available "gum"; then
        gum style --bold --foreground "$GUM_ACCENT" '   ->'
    else
        printf "   %b->%b"     \
            "${BOLD}${ACCENT}" \
            "${CLR}"
    fi
}


bullet_warning() {
    #
    # Output warning bullet with applied style.
    #
    if is_command_available "gum"; then
        printf "%b%b%b"                                              \
            "$(gum style --faint '[')"                               \
            "$(gum style --bold --foreground $GUM_YELLOW 'WARNING')" \
            "$(gum style --faint ']')"
    else
        printf "%b%b%b"                     \
            "${DIM}[${CLR}"                 \
            "${BOLD}${YELLOW}WARNING${CLR}" \
            "${DIM}]${CLR}"
    fi
}


bullet_error() {
    #
    # Output error bullet with applied style.
    #
    if is_command_available "gum"; then
        printf "%b%b%b"                                         \
            "$(gum style --faint '[')"                          \
            "$(gum style --bold --foreground $GUM_RED 'ERROR')" \
            "$(gum style --faint ']')"
    else
        printf "%b%b%b"                \
            "${DIM}[${CLR}"            \
            "${BOLD}${RED}ERROR${CLR}" \
            "${DIM}]${CLR}"
    fi
}


prefix_printf() {
    local prefix="$1"
    local title="$2"

    if is_command_available "gum"; then
        title="$(gum style --faint "$title")"
    else
        title="${DIM}${title}${CLR}"
    fi

    printf "%b ${title}" "$prefix" "${@:3}"
}


printf_section() {
    #
    # Print a section title with section prefix and style.
    #
    # Example:
    #   printf_section "Config file already exists, skipping"
    #   printf_section "Config file %s skipping" "${CONFIG_FILE}"
    #
    local title="$1"
    prefix_printf "$(bullet_section)" "${title}" "${@:2}"
}


printf_action() {
    #
    # Print a action title with action prefix and style.
    #
    # Example:
    #   printf_action "Install package gum - %b" "${INSTALL_STATUS}"
    #
    local title="$1"
    prefix_printf "$(bullet_action)" "${title}" "${@:2}"
}


printf_warning() {
    #
    # Print a warning message with the warning prefix.
    #
    # Example:
    #   printf_warning "Config file already exists"
    #
    local title="$1"
    prefix_printf "$(bullet_warning)" "${title}" "${@:2}"
}


printf_error() {
    #
    # Print a error message with the error prefix.
    #
    # Example:
    #   printf_error "Can't install package"
    #
    local title="$1"
    prefix_printf "$(bullet_error)" "${title}" "${@:2}"
}


## Input


ask_yn() {
    #
    # Ask a yes/no question, return 0 for yes, 1 for no
    #
    # Example:
    #   printf "Install gum? "
    #   if ask_yn; then as_root pacman -Sy gum; fi
    #
    printf "(y/n): "

    # read input from /dev/tty to work correctly when stdin is redirected
    # e.g., curl -fsSL ...install.sh | bash
    read -r reply </dev/tty

    if [[ $reply =~ ^[Yy]$ ]]; then
        return 0
    else
        return 1
    fi
}


## Root & Privilege


as_root() {
    #
    # Execute command as root (add sudo if necessary).
    # Returns the exit code of the command.
    #
    # Example:
    #   as_root pacman -Sy gum
    #
    if [ "$EUID" -eq 0 ]; then
        "$@"
    else
        sudo "$@"
    fi
}


check_sudo() {
    #
    # Check if sudo is needed (i.e., if not running as root).
    # Returns "sudo" if needed, empty string otherwise.
    #
    # Example:
    #   SUDO_PREFIX=$(check_sudo)
    #   $SUDO_PREFIX pacman -Sy gum
    #
    if [ "$EUID" -eq 0 ]; then
        # root already -> no need sudo
        echo ""
    else
        echo "sudo"
    fi
}


have_privilege() {
    #
    # Check whether the script has root privileges or a cached sudo credential.
    # Returns 0 if running as root or if `sudo` can be used without requiring a password,
    # returns 1 otherwise (sudo is required).
    #
    # Example:
    #   if have_privilege; then
    #       as_root pacman -Sy gum
    #   else
    #       info "Need password to perform privileged actions"
    #   fi
    #
    if [ "$EUID" -eq 0 ]; then
        # root privilege
        return 0
    fi

    # need sudo
    # shellcheck disable=SC2024
    if sudo -n true &>> "$LOG_FILE"; then
        # the privilege is still valid since last request
        return 0
    fi

    return 1 # need password
}


## Package Management


is_package_installed() {
    #
    # Check if a package installed.
    #
    # Parameters:
    #   $1 - package name
    #
    local package="$1"

    pacman -Qi "${package}" &>> "$LOG_FILE" && return 0
    return 1
}


request_gum() {
    #
    # Request user to install gum if it's not already installed.
    #
    # Example:
    #   gum_request
    #   assert $? "no gum - no fun :("
    #
    is_command_available "gum" && return 0

    printf_section "The UI%b gum%b not found. Let's get some? " \
        "${CLR}${BOLD}${MAGENTA}" \
        "${CLR}${DIM}"

    if ask_yn; then
        printf_action "pacman -Sy gum\n"
        as_root pacman -Sy gum </dev/tty
        echo
    else
        return 1
    fi
}


## Array


choices_to_indices() {
    #
    # Convert a newline-separated string of choices into their corresponding
    # indices in the provided source array.
    #
    # Example:
    #   indices=($(choices_to_indices "$file_choices" "${CONFIG_FILES[@]}"))
    #
    local choices="$1"
    shift
    local source_array=("$@")

    # Convert choices to array using mapfile
    local selected_items=()
    mapfile -t selected_items <<< "$choices"

    # Find indices
    local indices=()
    for item in "${selected_items[@]}"; do
        [[ -z "$item" ]] && continue  # Skip empty lines
        for i in "${!source_array[@]}"; do
            if [[ "${source_array[$i]}" == "$item" ]]; then
                indices+=("$i")
                break
            fi
        done
    done

    # Return indices as space-separated string
    echo "${indices[@]}"
}


array_contains() {
    #
    # Check if an array contains item(s) matching a given pattern.
    # The matching is case-sensitive and supports shell globbing.
    #
    # Example:
    #   if array_contains "^Keymap*" "${array[@]}"; then ...
    #
    local pattern="$1"
    shift
    local items=("$@")

    for item in "${items[@]}"; do
        if [[ $item =~ $pattern ]]; then
            return 0 # pattern found
        fi
    done

    return 1
}


## Files


backup_file() {
    #
    # Create a backup of the given file by appending .bakN
    # where N is the next available number.
    #
    # Parameters:
    #   $1 - filename to backup
    #   $2 - (optional) prefix command (e.g., "sudo")
    #
    # Example:
    #    backup_name=$(backup_file "$file")
    #    assert $? "backup failed for $file"
    #
    #    backup_name=$(backup_file "$file" "sudo")
    #    assert $? "backup failed for $file (with sudo)"
    #
    local filename="$1"
    local prefix="${2-}"

    # Тo target file -> nothing to back up
    if [[ ! -f $filename ]]; then
        echo ""  # return empty string
        return 0 # no error
    fi

    # Find the next available backup number
    local idx=1
    local backup_name="${filename}.bak${idx}"

    while [[ -f $backup_name ]]; do
        ((idx++))
        backup_name="${filename}.bak${idx}"
    done

    # Create the backup
    if $prefix cp "${filename}" "${backup_name}" &>> "$LOG_FILE"; then
        echo "${backup_name}" # return backup filename
        return 0
    else
        echo ""  # return empty string - no backup created
        return 1
    fi
}


remove_line() {
    #
    # Remove lines matching a given pattern from a file.
    #
    # Parameters:
    #   $1 - file to modify
    #   $2 - pattern to match (sed regex)
    #   $3 - (optional) prefix command (e.g., "sudo")
    #
    # Example:
    #   remove_line "/etc/vconsole.conf" "^FONT="
    #   assert $? "failed to remove line from /etc/vconsole.conf"
    #
    #   remove_line "/etc/vconsole.conf" "^FONT=" "sudo"
    #   assert $? "failed to remove line from /etc/vconsole.conf (with sudo)"
    #
    local file="$1"
    local pattern="$2"
    local prefix="${3-}"

    # Check if both parameters are provided
    if [[ -z $file || -z $pattern ]]; then
        assert 1 "both <file> and <pattern> parameters are required"
    fi

    # Check if file exists
    if [[ ! -f $file ]]; then
        return 0 # not file -> no line -> done
    fi

    # Remove lines matching the pattern using sed
    # -i flag edits the file in-place
    # The pattern is escaped to handle special characters safely
    if ! $prefix sed -i "\|${pattern}|d" "$file"; then
        return 1
    fi

    return 0
}


replace_line() {
    #
    # Replace lines matching a given pattern in a file with a new line.
    #
    # Parameters:
    #   $1 - file to modify
    #   $2 - pattern to match (sed regex)
    #   $3 - new line to insert
    #   $4 - (optional) prefix command (e.g., "sudo")
    #
    # Example:
    #   replace_line "/etc/vconsole.conf" "^FONT=" "FONT=ter-124b"
    #   assert $? "failed to replace line in /etc/vconsole.conf"
    #
    #   replace_line "/etc/vconsole.conf" "^FONT=" "FONT=ter-124b" "sudo"
    #   assert $? "failed to replace line in /etc/vconsole.conf (with sudo)"
    #
    local file="$1"
    local pattern="$2"
    local new_line="$3"
    local prefix="${4-}"

    # Check if all parameters are provided
    if [[ -z $file || -z $pattern || -z $new_line ]]; then
        assert 1 "parameters <file>, <pattern>, and <new_line> are required"
    fi

    # Check if file exists
    if [[ ! -f $file ]]; then
        return 1 # file not found
    fi

    # Replace lines matching the pattern using sed
    if ! $prefix sed -i "\|${pattern}|c\\${new_line}" "$file"; then
        return 1
    fi

    return 0
}


## TUI - gum-based


action_require_package() {
    #
    # Install a package using pacman with interactive UI and privilege handling.
    # Exit with 1 on failure.
    #
    # Parameters:
    #   $1 - package - The name of the package to install.
    #   $2 - title_prefix - A prefix string used when rendering UI titles (optional).
    #
    # Example:
    #   action_require_package "nano"
    #
    local package="$1"
    local title_prefix="${2-$(bullet_action) }"

    is_command_available "gum"
    assert $? "gum is required"

    action_title=$(printf "%b%b %b" "$title_prefix"  \
        "$(gum style --faint 'Package')"    \
        "$(gum style --bold --foreground "$GUM_ACCENT" "$package")" \
    )

    # check if package already installed
    gum spin --align="right" \
             --title "${action_title}$(gum style --faint ' - checking')" \
             -- sleep $UI_INTERACTION_DELAY

    if is_package_installed "$package"; then
        printf "%b\n" "${action_title}$(gum style --faint ' - exists')"
        return 0
    fi

    # request privilege
    gum spin --align="right" \
             --title "${action_title}$(gum style --faint ' - privilege')" \
             -- sleep $UI_INTERACTION_DELAY

    if ! have_privilege; then
        password=$(gum input --password --char-limit=30 \
                             --no-show-help             \
                             --placeholder "enter your password for sudo" \
                             --prompt "${action_title} $(gum style --foreground "$GUM_WHITE" '>') ")
        assert $? "password request failed"

        # shellcheck disable=SC2024
        echo "$password" | sudo -Si true &>> "$LOG_FILE"
        assert $? "privilege request failed"
    fi

    # pacman & spinner
    gum spin --align="right"  \
             --title "${action_title}$(gum style --faint ' - installing')" \
             -- bash -c "$(check_sudo) pacman --noconfirm -Sy ${package} &>> ${LOG_FILE}"
    assert $? "can't install package"

    printf "%b\n" "${action_title}$(gum style --faint ' - done')"
}


action_run() {
    #
    # Run a command with spinner. Print status is provided after the command finished.
    # Return the command exit code.
    #
    # Parameters:
    #   $1 - title - the action title to show.
    #   $2 - command - a command to run. The 'sleep' will be used if not provided.
    #   $3 - status - text to show after when the command finished (optional).
    #
    local title="$1"
    local command="${2-}"
    local status="${3-}"

    is_command_available "gum"
    assert $? "gum is required"

    # if command is missing set it to the minimal UI sleep
    if [ -z "$command" ]; then
        command="sleep $UI_INTERACTION_DELAY"
    fi

    # run command and show spinner
    gum spin --align="right" --title "$(printf_action "${title} -")" \
        -- bash -c "$command"

    # return exit code and skip status if non-zero
    exit_code=$?
    if [ $exit_code -ne 0 ]; then
        return $exit_code
    fi

    # show status if provided and command finished without an error
    if [ -z "$status" ]; then
        printf_action "%b\n" "$title"
    else
        printf_action "%b - %b\n" "$title" "$status"
    fi
}


action_request_permission() {
    #
    # Request root privilege via sudo and gum UI.
    # Exit with 1 on failure.
    #
    have_privilege && return 0

    # request user password for sudo
    request_title=$(printf_action "Request permission")
    password=$(gum input --password --char-limit=30 \
                         --no-show-help             \
                         --placeholder "enter your password for sudo" \
                         --prompt "${request_title} $(gum style --foreground "$GUM_WHITE" '>') ")
    assert $? "password request failed"

    # shellcheck disable=SC2024
    echo "$password" | sudo -Si true &>> "$LOG_FILE"
    assert $? "permission request failed"

    printf_action "Request permission - granted\n"
}
